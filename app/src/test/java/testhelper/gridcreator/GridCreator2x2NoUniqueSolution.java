package testhelper.gridcreator;

import net.mathdoku.plus.enums.CageOperator;
import net.mathdoku.plus.enums.GridType;
import net.mathdoku.plus.enums.PuzzleComplexity;
import net.mathdoku.plus.puzzle.grid.Grid;

/**
 * The test grid in this class has been generated with the specified generator version of the app. In case the grid is
 * recreated with the same grid generating parameters as specified by this class, the result should be equal to the grid
 * itself.
 * <p/>
 * All data in the methods below should be kept in sync with the specified version of the generator.
 * <p/>
 * As the data below was generated with hidden operators, this grid can be used with visible and with hidden operator as
 * well.
 */
public class GridCreator2x2NoUniqueSolution extends GridCreator {
    public static GridCreator2x2NoUniqueSolution create() {
        return new GridCreator2x2NoUniqueSolution();
    }

    public static GridCreator2x2NoUniqueSolution createEmpty() {
        GridCreator2x2NoUniqueSolution gridCreator = new GridCreator2x2NoUniqueSolution();
        gridCreator.setEmptyGrid();
        return gridCreator;
    }

    public static Grid createEmptyGrid() {
        return createEmpty().getGrid();
    }

    protected GridCreator2x2NoUniqueSolution() {
        super();
    }

    /**
     * This code is generated based on a grid which is generated by the app. To generate the code, use the app in
     * Development Mode. Choose menu option Development Options -> Generate code for test helper.
     * <p/>
     * DO NOT REMOVE THIS TEXT.
     */
    @Override
    protected long getGameSeed() {
        // This grid can not be created via the app as it is an invalid grid.
        return 0L;
    }

    protected GridType getGridType() {
        return GridType.GRID_2X2;
    }

    protected boolean getHideOperator() {
        return false;
    }

    protected PuzzleComplexity getPuzzleComplexity() {
        return PuzzleComplexity.VERY_EASY;
    }

    protected int getGeneratorVersionNumber() {
        return 598;
    }

    protected int getMaxCageResult() {
        return 72;
    }

    protected int getMaxCageSize() {
        return 2;
    }

    protected int[] getCorrectValuePerCell() {
        // This method returns just 1 out of 2 possible solutions!
        return new int[]{
                // Row 0
                1, 2,
                // Row 1
                2, 1,};
    }

    protected int[] getCageIdPerCell() {
        return new int[]{
                // Row 0
                0, 0,
                // Row 1
                1, 1,};
    }

    protected int[] getResultPerCage() {
        return new int[]{
                // Cage 0
                3,
                // Cage 1
                3,};
    }

    protected CageOperator[] getCageOperatorPerCage() {
        return new CageOperator[]{
                // Cage 0
                CageOperator.ADD,
                // Cage 1
                CageOperator.ADD,};
    }

    @Override
    public String getGridDefinition() {
        return new StringBuilder() //
                // PuzzleComplexity id
                .append("1").append(FIELD_SEPARATOR_GRID_DEFINITION_PART)
                        // Cage ids for cells on row 0
                .append("0000")
                        // Cage ids for cells on row 1
                .append("0101")
                        // Definition for cage id 0
                .append(FIELD_SEPARATOR_GRID_DEFINITION_PART).append("0,1,3")
                        // Definition for cage id 1
                .append(FIELD_SEPARATOR_GRID_DEFINITION_PART).append("1,1,3")
                .toString();
    }
}
