package net.cactii.mathdoku;

import java.util.ArrayList;

import android.util.Log;

public class CageTypeGenerator {
	public static final String TAG = "MathDoku.CageTypeGenerator";

	// Size of largest cage available.
	private int mMaxCageSize;

	// All available cage types.
	GridCageType mSingleCellCageType;
	ArrayList<GridCageType> mCageTypes;

	/**
	 * Creates a new instance of {@link CageTypeGenerator}.
	 * 
	 * @param maxCageSize
	 *            The maximum size of the cages.
	 */
	public CageTypeGenerator(int maxCageSize) {
		mCageTypes = new ArrayList<GridCageType>();

		// Start with a cage consisting of a single cell.
		boolean singleCageTypeMatrix[][] = new boolean[1][1];
		singleCageTypeMatrix[0][0] = true;
		mSingleCellCageType = addCageTypeIfNotExists(singleCageTypeMatrix);

		// The other cage types (size n) can be generated by adding one
		// additional cell to any cage having one cell less (size n-1).
		for (int cageSize = 2; cageSize <= maxCageSize; cageSize++) {

			// As the cageType list is extended, we need to make a clone of this
			// list for iterating in order to prevent a
			// java.util.ConcurrentModificationException. So we use a cloned
			// version of the mCageTypes list to iterate while modifying the
			// original list.
			ArrayList<GridCageType> cageTypesClone = new ArrayList<GridCageType>(mCageTypes);

			for (GridCageType cageType : cageTypesClone) {
				if (cageType.size() == cageSize - 1) {
					boolean newCageTypeMatrix[][] = cageType
							.getExtendedCageTypeMatrix();
					for (int row = 0; row < newCageTypeMatrix.length; row++) {
						for (int col = 0; col < newCageTypeMatrix[row].length; col++) {
							if (newCageTypeMatrix[row][col]) {
								// This cell was already occupied in the
								// original grid. Fill each free cell above,
								// right, below or left to create a new cage
								// type.

								// Because the ExtendedCageType has a free
								// border of emtpy cells around the cage there
								// is no need to check indexes.

								// Check above current occupied cell
								if (!newCageTypeMatrix[row - 1][col]) {
									newCageTypeMatrix[row - 1][col] = true;
									addCageTypeIfNotExists(newCageTypeMatrix);
									newCageTypeMatrix[row - 1][col] = false;
								}

								// Check to right of current occupied cell
								if (!newCageTypeMatrix[row][col + 1]) {
									newCageTypeMatrix[row][col + 1] = true;
									addCageTypeIfNotExists(newCageTypeMatrix);
									newCageTypeMatrix[row][col + 1] = false;
								}
								// Check below current occupied cell
								if (!newCageTypeMatrix[row + 1][col]) {
									newCageTypeMatrix[row + 1][col] = true;
									addCageTypeIfNotExists(newCageTypeMatrix);
									newCageTypeMatrix[row + 1][col] = false;
								}

								// Check to left of current occupied cell
								if (!newCageTypeMatrix[row][col - 1]) {
									newCageTypeMatrix[row][col - 1] = true;
									addCageTypeIfNotExists(newCageTypeMatrix);
									newCageTypeMatrix[row][col - 1] = false;
								}
							}
						}
					}
				}
			}
		}
	}

	/**
	 * Adds a new cage type to the list of cage types in case it is not yet on
	 * this list.
	 * 
	 * @param newCageTypeMatrix
	 *            The cage type matrix which has to be added to the list of
	 *            available cage types.
	 * @return The GridCageType if successfully added. Null otherwise.
	 */
	private GridCageType addCageTypeIfNotExists(boolean[][] newCageTypeMatrix) {
		GridCageType newPossibleCageType = new GridCageType();
		newPossibleCageType.setMatrix(newCageTypeMatrix);

		// Check if this cage type was not yet defined.
		if (mCageTypes.contains(newPossibleCageType)) {
			return null;
		}

		// This cage type does not yet exist.
		mCageTypes.add(newPossibleCageType);

		// Check if this is the largest cage type found until now.
		if (newPossibleCageType.size() > this.mMaxCageSize) {
			this.mMaxCageSize = newPossibleCageType.size();
		}

		if (GridGenerator.DEBUG_GRID_GENERATOR) {
			Log.i(TAG,
					"Found a new cage type:\n" + newPossibleCageType.toString());
		}

		return newPossibleCageType;
	}

	/**
	 * Gets the cage type for a single cell.
	 * 
	 * @return
	 */
	public GridCageType getSingleCellCageType() {
		return this.mSingleCellCageType;
	}

	/**
	 * Get the cage type with given index.
	 * 
	 * @param cageTypeIndex
	 *            The index of the cage type to be retrieved.
	 * 
	 * @return The cage type which was requested. Null in case of an error.
	 */
	public GridCageType getCageType(int cageTypeIndex) {
		return (mCageTypes == null ? null : mCageTypes.get(cageTypeIndex));
	}

	/**
	 * Get the size of the largest available cage type.
	 * 
	 * @return The size of the largest available cage type.
	 */
	public int getMaxCageSize() {
		return this.mMaxCageSize;
	}

	/**
	 * Get the number of available cage types.
	 * 
	 * @return the number of available cage types.
	 */
	public int size() {
		return mCageTypes.size();
	}
}